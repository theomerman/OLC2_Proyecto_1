Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CASE
    COMMENT
    COMMENT2
    DEFAULT
    FUNCTION
    INDEXOF
    JOIN
    KEYS
    LENGTH
    NULL
    OBJECT
    PARSEFLOAT
    PARSEINT
    POP
    PUSH
    SWITCH
    TOLOWERCASE
    TOSTRING
    TOUPPERCASE
    TYPEOF
    VALUES

Grammar

Rule 0     S' -> start
Rule 1     start -> init
Rule 2     init -> init instruction
Rule 3     init -> instruction
Rule 4     instruction -> declaration SEMICOLON
Rule 5     instruction -> assignment_const SEMICOLON
Rule 6     instruction -> assignment
Rule 7     instruction -> interface
Rule 8     instruction -> if
Rule 9     instruction -> while
Rule 10    instruction -> for
Rule 11    instruction -> foreach
Rule 12    instruction -> break
Rule 13    instruction -> continue
Rule 14    instruction -> return
Rule 15    instruction -> print
Rule 16    if -> IF LPAREN exp RPAREN block
Rule 17    if -> IF LPAREN exp RPAREN block ELSE block
Rule 18    if -> IF LPAREN exp RPAREN block ELSE if
Rule 19    if -> IF error
Rule 20    while -> WHILE LPAREN exp RPAREN block
Rule 21    for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block
Rule 22    foreach -> FOR LPAREN VAR ID OF ID RPAREN block
Rule 23    break -> BREAK SEMICOLON
Rule 24    continue -> CONTINUE SEMICOLON
Rule 25    return -> RETURN exp SEMICOLON
Rule 26    return -> RETURN SEMICOLON
Rule 27    block -> LBRACE init RBRACE
Rule 28    assignment_const -> CONST ID COLON type EQUAL exp
Rule 29    assignment_const -> CONST ID EQUAL exp
Rule 30    print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON
Rule 31    interface -> INTERFACE ID LBRACE interface_body RBRACE
Rule 32    interface_body -> interface_body SEMICOLON ID COLON type
Rule 33    interface_body -> ID COLON type
Rule 34    declaration -> VAR ID COLON type EQUAL exp
Rule 35    declaration -> VAR ID EQUAL exp
Rule 36    declaration -> VAR ID COLON type
Rule 37    declaration -> VAR error SEMICOLON
Rule 38    assignment -> ID EQUAL exp SEMICOLON
Rule 39    assignment -> ID PLUS_EQUAL exp SEMICOLON
Rule 40    assignment -> ID MINUS_EQUAL exp SEMICOLON
Rule 41    type -> TYPES
Rule 42    exp_list -> exp_list COMMA exp
Rule 43    exp_list -> exp
Rule 44    exp -> exp PLUS exp
Rule 45    exp -> exp MINUS exp
Rule 46    exp -> exp TIMES exp
Rule 47    exp -> exp DIVIDE exp
Rule 48    exp -> exp MOD exp
Rule 49    exp -> MINUS exp
Rule 50    exp -> NOT exp
Rule 51    exp -> exp COMPARASION exp
Rule 52    exp -> exp DIFFERENT exp
Rule 53    exp -> exp GREATER exp
Rule 54    exp -> exp LESS exp
Rule 55    exp -> exp GREATER_EQUAL exp
Rule 56    exp -> exp LESS_EQUAL exp
Rule 57    exp -> exp AND exp
Rule 58    exp -> exp OR exp
Rule 59    exp -> NUMBER_LEX
Rule 60    exp -> FLOAT_LEX
Rule 61    exp -> STRING_LEX
Rule 62    exp -> CHAR_LEX
Rule 63    exp -> BOOLEAN
Rule 64    exp -> list_array
Rule 65    list_array -> list_array LBRACKET exp RBRACKET
Rule 66    list_array -> list_array DOT ID
Rule 67    list_array -> ID
Rule 68    exp -> LPAREN exp RPAREN
Rule 69    exp -> exp QUESTION exp COLON exp
Rule 70    exp -> ID DOT ID
Rule 71    empty -> <empty>

Terminals, with rules where they appear

AND                  : 57
BOOLEAN              : 63
BREAK                : 23
CASE                 : 
CHAR_LEX             : 62
COLON                : 28 32 33 34 36 69
COMMA                : 42
COMMENT              : 
COMMENT2             : 
COMPARASION          : 51
CONSOLE              : 30
CONST                : 28 29
CONTINUE             : 24
DEFAULT              : 
DIFFERENT            : 52
DIVIDE               : 47
DOT                  : 30 66 70
ELSE                 : 17 18
EQUAL                : 28 29 34 35 38
FLOAT_LEX            : 60
FOR                  : 21 22
FUNCTION             : 
GREATER              : 53
GREATER_EQUAL        : 55
ID                   : 22 22 28 29 31 32 33 34 35 36 38 39 40 66 67 70 70
IF                   : 16 17 18 19
INDEXOF              : 
INTERFACE            : 31
JOIN                 : 
KEYS                 : 
LBRACE               : 27 31
LBRACKET             : 65
LENGTH               : 
LESS                 : 54
LESS_EQUAL           : 56
LOG                  : 30
LPAREN               : 16 17 18 20 21 22 30 68
MINUS                : 45 49
MINUS_EQUAL          : 40
MOD                  : 48
NOT                  : 50
NULL                 : 
NUMBER_LEX           : 59
OBJECT               : 
OF                   : 22
OR                   : 58
PARSEFLOAT           : 
PARSEINT             : 
PLUS                 : 44
PLUS_EQUAL           : 39
POP                  : 
PUSH                 : 
QUESTION             : 69
RBRACE               : 27 31
RBRACKET             : 65
RETURN               : 25 26
RPAREN               : 16 17 18 20 21 22 30 68
SEMICOLON            : 4 5 21 21 23 24 25 26 30 32 37 38 39 40
STRING_LEX           : 61
SWITCH               : 
TIMES                : 46
TOLOWERCASE          : 
TOSTRING             : 
TOUPPERCASE          : 
TYPEOF               : 
TYPES                : 41
VALUES               : 
VAR                  : 22 34 35 36 37
WHILE                : 20
error                : 19 37

Nonterminals, with rules where they appear

assignment           : 6
assignment_const     : 5
block                : 16 17 17 18 20 21 22
break                : 12
continue             : 13
declaration          : 4 21 21
empty                : 
exp                  : 16 17 18 20 21 25 28 29 34 35 38 39 40 42 43 44 44 45 45 46 46 47 47 48 48 49 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 65 68 69 69 69
exp_list             : 30 42
for                  : 10
foreach              : 11
if                   : 8 18
init                 : 1 2 27
instruction          : 2 3
interface            : 7
interface_body       : 31 32
list_array           : 64 65 66
print                : 15
return               : 14
start                : 0
type                 : 28 32 33 34 36
while                : 9

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . init
    (2) init -> . init instruction
    (3) init -> . instruction
    (4) instruction -> . declaration SEMICOLON
    (5) instruction -> . assignment_const SEMICOLON
    (6) instruction -> . assignment
    (7) instruction -> . interface
    (8) instruction -> . if
    (9) instruction -> . while
    (10) instruction -> . for
    (11) instruction -> . foreach
    (12) instruction -> . break
    (13) instruction -> . continue
    (14) instruction -> . return
    (15) instruction -> . print
    (34) declaration -> . VAR ID COLON type EQUAL exp
    (35) declaration -> . VAR ID EQUAL exp
    (36) declaration -> . VAR ID COLON type
    (37) declaration -> . VAR error SEMICOLON
    (28) assignment_const -> . CONST ID COLON type EQUAL exp
    (29) assignment_const -> . CONST ID EQUAL exp
    (38) assignment -> . ID EQUAL exp SEMICOLON
    (39) assignment -> . ID PLUS_EQUAL exp SEMICOLON
    (40) assignment -> . ID MINUS_EQUAL exp SEMICOLON
    (31) interface -> . INTERFACE ID LBRACE interface_body RBRACE
    (16) if -> . IF LPAREN exp RPAREN block
    (17) if -> . IF LPAREN exp RPAREN block ELSE block
    (18) if -> . IF LPAREN exp RPAREN block ELSE if
    (19) if -> . IF error
    (20) while -> . WHILE LPAREN exp RPAREN block
    (21) for -> . FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block
    (22) foreach -> . FOR LPAREN VAR ID OF ID RPAREN block
    (23) break -> . BREAK SEMICOLON
    (24) continue -> . CONTINUE SEMICOLON
    (25) return -> . RETURN exp SEMICOLON
    (26) return -> . RETURN SEMICOLON
    (30) print -> . CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON

    VAR             shift and go to state 16
    CONST           shift and go to state 18
    ID              shift and go to state 17
    INTERFACE       shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    RETURN          shift and go to state 25
    CONSOLE         shift and go to state 26

    start                          shift and go to state 1
    init                           shift and go to state 2
    instruction                    shift and go to state 3
    declaration                    shift and go to state 4
    assignment_const               shift and go to state 5
    assignment                     shift and go to state 6
    interface                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    foreach                        shift and go to state 11
    break                          shift and go to state 12
    continue                       shift and go to state 13
    return                         shift and go to state 14
    print                          shift and go to state 15

state 1

    (0) S' -> start .



state 2

    (1) start -> init .
    (2) init -> init . instruction
    (4) instruction -> . declaration SEMICOLON
    (5) instruction -> . assignment_const SEMICOLON
    (6) instruction -> . assignment
    (7) instruction -> . interface
    (8) instruction -> . if
    (9) instruction -> . while
    (10) instruction -> . for
    (11) instruction -> . foreach
    (12) instruction -> . break
    (13) instruction -> . continue
    (14) instruction -> . return
    (15) instruction -> . print
    (34) declaration -> . VAR ID COLON type EQUAL exp
    (35) declaration -> . VAR ID EQUAL exp
    (36) declaration -> . VAR ID COLON type
    (37) declaration -> . VAR error SEMICOLON
    (28) assignment_const -> . CONST ID COLON type EQUAL exp
    (29) assignment_const -> . CONST ID EQUAL exp
    (38) assignment -> . ID EQUAL exp SEMICOLON
    (39) assignment -> . ID PLUS_EQUAL exp SEMICOLON
    (40) assignment -> . ID MINUS_EQUAL exp SEMICOLON
    (31) interface -> . INTERFACE ID LBRACE interface_body RBRACE
    (16) if -> . IF LPAREN exp RPAREN block
    (17) if -> . IF LPAREN exp RPAREN block ELSE block
    (18) if -> . IF LPAREN exp RPAREN block ELSE if
    (19) if -> . IF error
    (20) while -> . WHILE LPAREN exp RPAREN block
    (21) for -> . FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block
    (22) foreach -> . FOR LPAREN VAR ID OF ID RPAREN block
    (23) break -> . BREAK SEMICOLON
    (24) continue -> . CONTINUE SEMICOLON
    (25) return -> . RETURN exp SEMICOLON
    (26) return -> . RETURN SEMICOLON
    (30) print -> . CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON

    $end            reduce using rule 1 (start -> init .)
    VAR             shift and go to state 16
    CONST           shift and go to state 18
    ID              shift and go to state 17
    INTERFACE       shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    RETURN          shift and go to state 25
    CONSOLE         shift and go to state 26

    instruction                    shift and go to state 27
    declaration                    shift and go to state 4
    assignment_const               shift and go to state 5
    assignment                     shift and go to state 6
    interface                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    foreach                        shift and go to state 11
    break                          shift and go to state 12
    continue                       shift and go to state 13
    return                         shift and go to state 14
    print                          shift and go to state 15

state 3

    (3) init -> instruction .

    VAR             reduce using rule 3 (init -> instruction .)
    CONST           reduce using rule 3 (init -> instruction .)
    ID              reduce using rule 3 (init -> instruction .)
    INTERFACE       reduce using rule 3 (init -> instruction .)
    IF              reduce using rule 3 (init -> instruction .)
    WHILE           reduce using rule 3 (init -> instruction .)
    FOR             reduce using rule 3 (init -> instruction .)
    BREAK           reduce using rule 3 (init -> instruction .)
    CONTINUE        reduce using rule 3 (init -> instruction .)
    RETURN          reduce using rule 3 (init -> instruction .)
    CONSOLE         reduce using rule 3 (init -> instruction .)
    $end            reduce using rule 3 (init -> instruction .)
    RBRACE          reduce using rule 3 (init -> instruction .)


state 4

    (4) instruction -> declaration . SEMICOLON

    SEMICOLON       shift and go to state 28


state 5

    (5) instruction -> assignment_const . SEMICOLON

    SEMICOLON       shift and go to state 29


state 6

    (6) instruction -> assignment .

    VAR             reduce using rule 6 (instruction -> assignment .)
    CONST           reduce using rule 6 (instruction -> assignment .)
    ID              reduce using rule 6 (instruction -> assignment .)
    INTERFACE       reduce using rule 6 (instruction -> assignment .)
    IF              reduce using rule 6 (instruction -> assignment .)
    WHILE           reduce using rule 6 (instruction -> assignment .)
    FOR             reduce using rule 6 (instruction -> assignment .)
    BREAK           reduce using rule 6 (instruction -> assignment .)
    CONTINUE        reduce using rule 6 (instruction -> assignment .)
    RETURN          reduce using rule 6 (instruction -> assignment .)
    CONSOLE         reduce using rule 6 (instruction -> assignment .)
    $end            reduce using rule 6 (instruction -> assignment .)
    RBRACE          reduce using rule 6 (instruction -> assignment .)


state 7

    (7) instruction -> interface .

    VAR             reduce using rule 7 (instruction -> interface .)
    CONST           reduce using rule 7 (instruction -> interface .)
    ID              reduce using rule 7 (instruction -> interface .)
    INTERFACE       reduce using rule 7 (instruction -> interface .)
    IF              reduce using rule 7 (instruction -> interface .)
    WHILE           reduce using rule 7 (instruction -> interface .)
    FOR             reduce using rule 7 (instruction -> interface .)
    BREAK           reduce using rule 7 (instruction -> interface .)
    CONTINUE        reduce using rule 7 (instruction -> interface .)
    RETURN          reduce using rule 7 (instruction -> interface .)
    CONSOLE         reduce using rule 7 (instruction -> interface .)
    $end            reduce using rule 7 (instruction -> interface .)
    RBRACE          reduce using rule 7 (instruction -> interface .)


state 8

    (8) instruction -> if .

    VAR             reduce using rule 8 (instruction -> if .)
    CONST           reduce using rule 8 (instruction -> if .)
    ID              reduce using rule 8 (instruction -> if .)
    INTERFACE       reduce using rule 8 (instruction -> if .)
    IF              reduce using rule 8 (instruction -> if .)
    WHILE           reduce using rule 8 (instruction -> if .)
    FOR             reduce using rule 8 (instruction -> if .)
    BREAK           reduce using rule 8 (instruction -> if .)
    CONTINUE        reduce using rule 8 (instruction -> if .)
    RETURN          reduce using rule 8 (instruction -> if .)
    CONSOLE         reduce using rule 8 (instruction -> if .)
    $end            reduce using rule 8 (instruction -> if .)
    RBRACE          reduce using rule 8 (instruction -> if .)


state 9

    (9) instruction -> while .

    VAR             reduce using rule 9 (instruction -> while .)
    CONST           reduce using rule 9 (instruction -> while .)
    ID              reduce using rule 9 (instruction -> while .)
    INTERFACE       reduce using rule 9 (instruction -> while .)
    IF              reduce using rule 9 (instruction -> while .)
    WHILE           reduce using rule 9 (instruction -> while .)
    FOR             reduce using rule 9 (instruction -> while .)
    BREAK           reduce using rule 9 (instruction -> while .)
    CONTINUE        reduce using rule 9 (instruction -> while .)
    RETURN          reduce using rule 9 (instruction -> while .)
    CONSOLE         reduce using rule 9 (instruction -> while .)
    $end            reduce using rule 9 (instruction -> while .)
    RBRACE          reduce using rule 9 (instruction -> while .)


state 10

    (10) instruction -> for .

    VAR             reduce using rule 10 (instruction -> for .)
    CONST           reduce using rule 10 (instruction -> for .)
    ID              reduce using rule 10 (instruction -> for .)
    INTERFACE       reduce using rule 10 (instruction -> for .)
    IF              reduce using rule 10 (instruction -> for .)
    WHILE           reduce using rule 10 (instruction -> for .)
    FOR             reduce using rule 10 (instruction -> for .)
    BREAK           reduce using rule 10 (instruction -> for .)
    CONTINUE        reduce using rule 10 (instruction -> for .)
    RETURN          reduce using rule 10 (instruction -> for .)
    CONSOLE         reduce using rule 10 (instruction -> for .)
    $end            reduce using rule 10 (instruction -> for .)
    RBRACE          reduce using rule 10 (instruction -> for .)


state 11

    (11) instruction -> foreach .

    VAR             reduce using rule 11 (instruction -> foreach .)
    CONST           reduce using rule 11 (instruction -> foreach .)
    ID              reduce using rule 11 (instruction -> foreach .)
    INTERFACE       reduce using rule 11 (instruction -> foreach .)
    IF              reduce using rule 11 (instruction -> foreach .)
    WHILE           reduce using rule 11 (instruction -> foreach .)
    FOR             reduce using rule 11 (instruction -> foreach .)
    BREAK           reduce using rule 11 (instruction -> foreach .)
    CONTINUE        reduce using rule 11 (instruction -> foreach .)
    RETURN          reduce using rule 11 (instruction -> foreach .)
    CONSOLE         reduce using rule 11 (instruction -> foreach .)
    $end            reduce using rule 11 (instruction -> foreach .)
    RBRACE          reduce using rule 11 (instruction -> foreach .)


state 12

    (12) instruction -> break .

    VAR             reduce using rule 12 (instruction -> break .)
    CONST           reduce using rule 12 (instruction -> break .)
    ID              reduce using rule 12 (instruction -> break .)
    INTERFACE       reduce using rule 12 (instruction -> break .)
    IF              reduce using rule 12 (instruction -> break .)
    WHILE           reduce using rule 12 (instruction -> break .)
    FOR             reduce using rule 12 (instruction -> break .)
    BREAK           reduce using rule 12 (instruction -> break .)
    CONTINUE        reduce using rule 12 (instruction -> break .)
    RETURN          reduce using rule 12 (instruction -> break .)
    CONSOLE         reduce using rule 12 (instruction -> break .)
    $end            reduce using rule 12 (instruction -> break .)
    RBRACE          reduce using rule 12 (instruction -> break .)


state 13

    (13) instruction -> continue .

    VAR             reduce using rule 13 (instruction -> continue .)
    CONST           reduce using rule 13 (instruction -> continue .)
    ID              reduce using rule 13 (instruction -> continue .)
    INTERFACE       reduce using rule 13 (instruction -> continue .)
    IF              reduce using rule 13 (instruction -> continue .)
    WHILE           reduce using rule 13 (instruction -> continue .)
    FOR             reduce using rule 13 (instruction -> continue .)
    BREAK           reduce using rule 13 (instruction -> continue .)
    CONTINUE        reduce using rule 13 (instruction -> continue .)
    RETURN          reduce using rule 13 (instruction -> continue .)
    CONSOLE         reduce using rule 13 (instruction -> continue .)
    $end            reduce using rule 13 (instruction -> continue .)
    RBRACE          reduce using rule 13 (instruction -> continue .)


state 14

    (14) instruction -> return .

    VAR             reduce using rule 14 (instruction -> return .)
    CONST           reduce using rule 14 (instruction -> return .)
    ID              reduce using rule 14 (instruction -> return .)
    INTERFACE       reduce using rule 14 (instruction -> return .)
    IF              reduce using rule 14 (instruction -> return .)
    WHILE           reduce using rule 14 (instruction -> return .)
    FOR             reduce using rule 14 (instruction -> return .)
    BREAK           reduce using rule 14 (instruction -> return .)
    CONTINUE        reduce using rule 14 (instruction -> return .)
    RETURN          reduce using rule 14 (instruction -> return .)
    CONSOLE         reduce using rule 14 (instruction -> return .)
    $end            reduce using rule 14 (instruction -> return .)
    RBRACE          reduce using rule 14 (instruction -> return .)


state 15

    (15) instruction -> print .

    VAR             reduce using rule 15 (instruction -> print .)
    CONST           reduce using rule 15 (instruction -> print .)
    ID              reduce using rule 15 (instruction -> print .)
    INTERFACE       reduce using rule 15 (instruction -> print .)
    IF              reduce using rule 15 (instruction -> print .)
    WHILE           reduce using rule 15 (instruction -> print .)
    FOR             reduce using rule 15 (instruction -> print .)
    BREAK           reduce using rule 15 (instruction -> print .)
    CONTINUE        reduce using rule 15 (instruction -> print .)
    RETURN          reduce using rule 15 (instruction -> print .)
    CONSOLE         reduce using rule 15 (instruction -> print .)
    $end            reduce using rule 15 (instruction -> print .)
    RBRACE          reduce using rule 15 (instruction -> print .)


state 16

    (34) declaration -> VAR . ID COLON type EQUAL exp
    (35) declaration -> VAR . ID EQUAL exp
    (36) declaration -> VAR . ID COLON type
    (37) declaration -> VAR . error SEMICOLON

    ID              shift and go to state 30
    error           shift and go to state 31


state 17

    (38) assignment -> ID . EQUAL exp SEMICOLON
    (39) assignment -> ID . PLUS_EQUAL exp SEMICOLON
    (40) assignment -> ID . MINUS_EQUAL exp SEMICOLON

    EQUAL           shift and go to state 32
    PLUS_EQUAL      shift and go to state 33
    MINUS_EQUAL     shift and go to state 34


state 18

    (28) assignment_const -> CONST . ID COLON type EQUAL exp
    (29) assignment_const -> CONST . ID EQUAL exp

    ID              shift and go to state 35


state 19

    (31) interface -> INTERFACE . ID LBRACE interface_body RBRACE

    ID              shift and go to state 36


state 20

    (16) if -> IF . LPAREN exp RPAREN block
    (17) if -> IF . LPAREN exp RPAREN block ELSE block
    (18) if -> IF . LPAREN exp RPAREN block ELSE if
    (19) if -> IF . error

    LPAREN          shift and go to state 37
    error           shift and go to state 38


state 21

    (20) while -> WHILE . LPAREN exp RPAREN block

    LPAREN          shift and go to state 39


state 22

    (21) for -> FOR . LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block
    (22) foreach -> FOR . LPAREN VAR ID OF ID RPAREN block

    LPAREN          shift and go to state 40


state 23

    (23) break -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 41


state 24

    (24) continue -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 42


state 25

    (25) return -> RETURN . exp SEMICOLON
    (26) return -> RETURN . SEMICOLON
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    SEMICOLON       shift and go to state 44
    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 43
    list_array                     shift and go to state 52

state 26

    (30) print -> CONSOLE . DOT LOG LPAREN exp_list RPAREN SEMICOLON

    DOT             shift and go to state 55


state 27

    (2) init -> init instruction .

    VAR             reduce using rule 2 (init -> init instruction .)
    CONST           reduce using rule 2 (init -> init instruction .)
    ID              reduce using rule 2 (init -> init instruction .)
    INTERFACE       reduce using rule 2 (init -> init instruction .)
    IF              reduce using rule 2 (init -> init instruction .)
    WHILE           reduce using rule 2 (init -> init instruction .)
    FOR             reduce using rule 2 (init -> init instruction .)
    BREAK           reduce using rule 2 (init -> init instruction .)
    CONTINUE        reduce using rule 2 (init -> init instruction .)
    RETURN          reduce using rule 2 (init -> init instruction .)
    CONSOLE         reduce using rule 2 (init -> init instruction .)
    $end            reduce using rule 2 (init -> init instruction .)
    RBRACE          reduce using rule 2 (init -> init instruction .)


state 28

    (4) instruction -> declaration SEMICOLON .

    VAR             reduce using rule 4 (instruction -> declaration SEMICOLON .)
    CONST           reduce using rule 4 (instruction -> declaration SEMICOLON .)
    ID              reduce using rule 4 (instruction -> declaration SEMICOLON .)
    INTERFACE       reduce using rule 4 (instruction -> declaration SEMICOLON .)
    IF              reduce using rule 4 (instruction -> declaration SEMICOLON .)
    WHILE           reduce using rule 4 (instruction -> declaration SEMICOLON .)
    FOR             reduce using rule 4 (instruction -> declaration SEMICOLON .)
    BREAK           reduce using rule 4 (instruction -> declaration SEMICOLON .)
    CONTINUE        reduce using rule 4 (instruction -> declaration SEMICOLON .)
    RETURN          reduce using rule 4 (instruction -> declaration SEMICOLON .)
    CONSOLE         reduce using rule 4 (instruction -> declaration SEMICOLON .)
    $end            reduce using rule 4 (instruction -> declaration SEMICOLON .)
    RBRACE          reduce using rule 4 (instruction -> declaration SEMICOLON .)


state 29

    (5) instruction -> assignment_const SEMICOLON .

    VAR             reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    CONST           reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    ID              reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    INTERFACE       reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    IF              reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    WHILE           reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    FOR             reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    BREAK           reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    CONTINUE        reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    RETURN          reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    CONSOLE         reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    $end            reduce using rule 5 (instruction -> assignment_const SEMICOLON .)
    RBRACE          reduce using rule 5 (instruction -> assignment_const SEMICOLON .)


state 30

    (34) declaration -> VAR ID . COLON type EQUAL exp
    (35) declaration -> VAR ID . EQUAL exp
    (36) declaration -> VAR ID . COLON type

    COLON           shift and go to state 56
    EQUAL           shift and go to state 57


state 31

    (37) declaration -> VAR error . SEMICOLON

    SEMICOLON       shift and go to state 58


state 32

    (38) assignment -> ID EQUAL . exp SEMICOLON
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 59
    list_array                     shift and go to state 52

state 33

    (39) assignment -> ID PLUS_EQUAL . exp SEMICOLON
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 60
    list_array                     shift and go to state 52

state 34

    (40) assignment -> ID MINUS_EQUAL . exp SEMICOLON
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 61
    list_array                     shift and go to state 52

state 35

    (28) assignment_const -> CONST ID . COLON type EQUAL exp
    (29) assignment_const -> CONST ID . EQUAL exp

    COLON           shift and go to state 62
    EQUAL           shift and go to state 63


state 36

    (31) interface -> INTERFACE ID . LBRACE interface_body RBRACE

    LBRACE          shift and go to state 64


state 37

    (16) if -> IF LPAREN . exp RPAREN block
    (17) if -> IF LPAREN . exp RPAREN block ELSE block
    (18) if -> IF LPAREN . exp RPAREN block ELSE if
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 65
    list_array                     shift and go to state 52

state 38

    (19) if -> IF error .

    VAR             reduce using rule 19 (if -> IF error .)
    CONST           reduce using rule 19 (if -> IF error .)
    ID              reduce using rule 19 (if -> IF error .)
    INTERFACE       reduce using rule 19 (if -> IF error .)
    IF              reduce using rule 19 (if -> IF error .)
    WHILE           reduce using rule 19 (if -> IF error .)
    FOR             reduce using rule 19 (if -> IF error .)
    BREAK           reduce using rule 19 (if -> IF error .)
    CONTINUE        reduce using rule 19 (if -> IF error .)
    RETURN          reduce using rule 19 (if -> IF error .)
    CONSOLE         reduce using rule 19 (if -> IF error .)
    $end            reduce using rule 19 (if -> IF error .)
    RBRACE          reduce using rule 19 (if -> IF error .)


state 39

    (20) while -> WHILE LPAREN . exp RPAREN block
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 66
    list_array                     shift and go to state 52

state 40

    (21) for -> FOR LPAREN . declaration SEMICOLON exp SEMICOLON declaration RPAREN block
    (22) foreach -> FOR LPAREN . VAR ID OF ID RPAREN block
    (34) declaration -> . VAR ID COLON type EQUAL exp
    (35) declaration -> . VAR ID EQUAL exp
    (36) declaration -> . VAR ID COLON type
    (37) declaration -> . VAR error SEMICOLON

    VAR             shift and go to state 68

    declaration                    shift and go to state 67

state 41

    (23) break -> BREAK SEMICOLON .

    VAR             reduce using rule 23 (break -> BREAK SEMICOLON .)
    CONST           reduce using rule 23 (break -> BREAK SEMICOLON .)
    ID              reduce using rule 23 (break -> BREAK SEMICOLON .)
    INTERFACE       reduce using rule 23 (break -> BREAK SEMICOLON .)
    IF              reduce using rule 23 (break -> BREAK SEMICOLON .)
    WHILE           reduce using rule 23 (break -> BREAK SEMICOLON .)
    FOR             reduce using rule 23 (break -> BREAK SEMICOLON .)
    BREAK           reduce using rule 23 (break -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 23 (break -> BREAK SEMICOLON .)
    RETURN          reduce using rule 23 (break -> BREAK SEMICOLON .)
    CONSOLE         reduce using rule 23 (break -> BREAK SEMICOLON .)
    $end            reduce using rule 23 (break -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 23 (break -> BREAK SEMICOLON .)


state 42

    (24) continue -> CONTINUE SEMICOLON .

    VAR             reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    CONST           reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    ID              reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    INTERFACE       reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    IF              reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    CONSOLE         reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    $end            reduce using rule 24 (continue -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 24 (continue -> CONTINUE SEMICOLON .)


state 43

    (25) return -> RETURN exp . SEMICOLON
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       shift and go to state 69
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 44

    (26) return -> RETURN SEMICOLON .

    VAR             reduce using rule 26 (return -> RETURN SEMICOLON .)
    CONST           reduce using rule 26 (return -> RETURN SEMICOLON .)
    ID              reduce using rule 26 (return -> RETURN SEMICOLON .)
    INTERFACE       reduce using rule 26 (return -> RETURN SEMICOLON .)
    IF              reduce using rule 26 (return -> RETURN SEMICOLON .)
    WHILE           reduce using rule 26 (return -> RETURN SEMICOLON .)
    FOR             reduce using rule 26 (return -> RETURN SEMICOLON .)
    BREAK           reduce using rule 26 (return -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 26 (return -> RETURN SEMICOLON .)
    RETURN          reduce using rule 26 (return -> RETURN SEMICOLON .)
    CONSOLE         reduce using rule 26 (return -> RETURN SEMICOLON .)
    $end            reduce using rule 26 (return -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 26 (return -> RETURN SEMICOLON .)


state 45

    (49) exp -> MINUS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 84
    list_array                     shift and go to state 52

state 46

    (50) exp -> NOT . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 85
    list_array                     shift and go to state 52

state 47

    (59) exp -> NUMBER_LEX .

    SEMICOLON       reduce using rule 59 (exp -> NUMBER_LEX .)
    PLUS            reduce using rule 59 (exp -> NUMBER_LEX .)
    MINUS           reduce using rule 59 (exp -> NUMBER_LEX .)
    TIMES           reduce using rule 59 (exp -> NUMBER_LEX .)
    DIVIDE          reduce using rule 59 (exp -> NUMBER_LEX .)
    MOD             reduce using rule 59 (exp -> NUMBER_LEX .)
    COMPARASION     reduce using rule 59 (exp -> NUMBER_LEX .)
    DIFFERENT       reduce using rule 59 (exp -> NUMBER_LEX .)
    GREATER         reduce using rule 59 (exp -> NUMBER_LEX .)
    LESS            reduce using rule 59 (exp -> NUMBER_LEX .)
    GREATER_EQUAL   reduce using rule 59 (exp -> NUMBER_LEX .)
    LESS_EQUAL      reduce using rule 59 (exp -> NUMBER_LEX .)
    AND             reduce using rule 59 (exp -> NUMBER_LEX .)
    OR              reduce using rule 59 (exp -> NUMBER_LEX .)
    QUESTION        reduce using rule 59 (exp -> NUMBER_LEX .)
    RPAREN          reduce using rule 59 (exp -> NUMBER_LEX .)
    COLON           reduce using rule 59 (exp -> NUMBER_LEX .)
    RBRACKET        reduce using rule 59 (exp -> NUMBER_LEX .)
    COMMA           reduce using rule 59 (exp -> NUMBER_LEX .)


state 48

    (60) exp -> FLOAT_LEX .

    SEMICOLON       reduce using rule 60 (exp -> FLOAT_LEX .)
    PLUS            reduce using rule 60 (exp -> FLOAT_LEX .)
    MINUS           reduce using rule 60 (exp -> FLOAT_LEX .)
    TIMES           reduce using rule 60 (exp -> FLOAT_LEX .)
    DIVIDE          reduce using rule 60 (exp -> FLOAT_LEX .)
    MOD             reduce using rule 60 (exp -> FLOAT_LEX .)
    COMPARASION     reduce using rule 60 (exp -> FLOAT_LEX .)
    DIFFERENT       reduce using rule 60 (exp -> FLOAT_LEX .)
    GREATER         reduce using rule 60 (exp -> FLOAT_LEX .)
    LESS            reduce using rule 60 (exp -> FLOAT_LEX .)
    GREATER_EQUAL   reduce using rule 60 (exp -> FLOAT_LEX .)
    LESS_EQUAL      reduce using rule 60 (exp -> FLOAT_LEX .)
    AND             reduce using rule 60 (exp -> FLOAT_LEX .)
    OR              reduce using rule 60 (exp -> FLOAT_LEX .)
    QUESTION        reduce using rule 60 (exp -> FLOAT_LEX .)
    RPAREN          reduce using rule 60 (exp -> FLOAT_LEX .)
    COLON           reduce using rule 60 (exp -> FLOAT_LEX .)
    RBRACKET        reduce using rule 60 (exp -> FLOAT_LEX .)
    COMMA           reduce using rule 60 (exp -> FLOAT_LEX .)


state 49

    (61) exp -> STRING_LEX .

    SEMICOLON       reduce using rule 61 (exp -> STRING_LEX .)
    PLUS            reduce using rule 61 (exp -> STRING_LEX .)
    MINUS           reduce using rule 61 (exp -> STRING_LEX .)
    TIMES           reduce using rule 61 (exp -> STRING_LEX .)
    DIVIDE          reduce using rule 61 (exp -> STRING_LEX .)
    MOD             reduce using rule 61 (exp -> STRING_LEX .)
    COMPARASION     reduce using rule 61 (exp -> STRING_LEX .)
    DIFFERENT       reduce using rule 61 (exp -> STRING_LEX .)
    GREATER         reduce using rule 61 (exp -> STRING_LEX .)
    LESS            reduce using rule 61 (exp -> STRING_LEX .)
    GREATER_EQUAL   reduce using rule 61 (exp -> STRING_LEX .)
    LESS_EQUAL      reduce using rule 61 (exp -> STRING_LEX .)
    AND             reduce using rule 61 (exp -> STRING_LEX .)
    OR              reduce using rule 61 (exp -> STRING_LEX .)
    QUESTION        reduce using rule 61 (exp -> STRING_LEX .)
    RPAREN          reduce using rule 61 (exp -> STRING_LEX .)
    COLON           reduce using rule 61 (exp -> STRING_LEX .)
    RBRACKET        reduce using rule 61 (exp -> STRING_LEX .)
    COMMA           reduce using rule 61 (exp -> STRING_LEX .)


state 50

    (62) exp -> CHAR_LEX .

    SEMICOLON       reduce using rule 62 (exp -> CHAR_LEX .)
    PLUS            reduce using rule 62 (exp -> CHAR_LEX .)
    MINUS           reduce using rule 62 (exp -> CHAR_LEX .)
    TIMES           reduce using rule 62 (exp -> CHAR_LEX .)
    DIVIDE          reduce using rule 62 (exp -> CHAR_LEX .)
    MOD             reduce using rule 62 (exp -> CHAR_LEX .)
    COMPARASION     reduce using rule 62 (exp -> CHAR_LEX .)
    DIFFERENT       reduce using rule 62 (exp -> CHAR_LEX .)
    GREATER         reduce using rule 62 (exp -> CHAR_LEX .)
    LESS            reduce using rule 62 (exp -> CHAR_LEX .)
    GREATER_EQUAL   reduce using rule 62 (exp -> CHAR_LEX .)
    LESS_EQUAL      reduce using rule 62 (exp -> CHAR_LEX .)
    AND             reduce using rule 62 (exp -> CHAR_LEX .)
    OR              reduce using rule 62 (exp -> CHAR_LEX .)
    QUESTION        reduce using rule 62 (exp -> CHAR_LEX .)
    RPAREN          reduce using rule 62 (exp -> CHAR_LEX .)
    COLON           reduce using rule 62 (exp -> CHAR_LEX .)
    RBRACKET        reduce using rule 62 (exp -> CHAR_LEX .)
    COMMA           reduce using rule 62 (exp -> CHAR_LEX .)


state 51

    (63) exp -> BOOLEAN .

    SEMICOLON       reduce using rule 63 (exp -> BOOLEAN .)
    PLUS            reduce using rule 63 (exp -> BOOLEAN .)
    MINUS           reduce using rule 63 (exp -> BOOLEAN .)
    TIMES           reduce using rule 63 (exp -> BOOLEAN .)
    DIVIDE          reduce using rule 63 (exp -> BOOLEAN .)
    MOD             reduce using rule 63 (exp -> BOOLEAN .)
    COMPARASION     reduce using rule 63 (exp -> BOOLEAN .)
    DIFFERENT       reduce using rule 63 (exp -> BOOLEAN .)
    GREATER         reduce using rule 63 (exp -> BOOLEAN .)
    LESS            reduce using rule 63 (exp -> BOOLEAN .)
    GREATER_EQUAL   reduce using rule 63 (exp -> BOOLEAN .)
    LESS_EQUAL      reduce using rule 63 (exp -> BOOLEAN .)
    AND             reduce using rule 63 (exp -> BOOLEAN .)
    OR              reduce using rule 63 (exp -> BOOLEAN .)
    QUESTION        reduce using rule 63 (exp -> BOOLEAN .)
    RPAREN          reduce using rule 63 (exp -> BOOLEAN .)
    COLON           reduce using rule 63 (exp -> BOOLEAN .)
    RBRACKET        reduce using rule 63 (exp -> BOOLEAN .)
    COMMA           reduce using rule 63 (exp -> BOOLEAN .)


state 52

    (64) exp -> list_array .
    (65) list_array -> list_array . LBRACKET exp RBRACKET
    (66) list_array -> list_array . DOT ID

    SEMICOLON       reduce using rule 64 (exp -> list_array .)
    PLUS            reduce using rule 64 (exp -> list_array .)
    MINUS           reduce using rule 64 (exp -> list_array .)
    TIMES           reduce using rule 64 (exp -> list_array .)
    DIVIDE          reduce using rule 64 (exp -> list_array .)
    MOD             reduce using rule 64 (exp -> list_array .)
    COMPARASION     reduce using rule 64 (exp -> list_array .)
    DIFFERENT       reduce using rule 64 (exp -> list_array .)
    GREATER         reduce using rule 64 (exp -> list_array .)
    LESS            reduce using rule 64 (exp -> list_array .)
    GREATER_EQUAL   reduce using rule 64 (exp -> list_array .)
    LESS_EQUAL      reduce using rule 64 (exp -> list_array .)
    AND             reduce using rule 64 (exp -> list_array .)
    OR              reduce using rule 64 (exp -> list_array .)
    QUESTION        reduce using rule 64 (exp -> list_array .)
    RPAREN          reduce using rule 64 (exp -> list_array .)
    COLON           reduce using rule 64 (exp -> list_array .)
    RBRACKET        reduce using rule 64 (exp -> list_array .)
    COMMA           reduce using rule 64 (exp -> list_array .)
    LBRACKET        shift and go to state 86
    DOT             shift and go to state 87


state 53

    (68) exp -> LPAREN . exp RPAREN
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 88
    list_array                     shift and go to state 52

state 54

    (70) exp -> ID . DOT ID
    (67) list_array -> ID .

  ! shift/reduce conflict for DOT resolved as shift
    DOT             shift and go to state 89
    LBRACKET        reduce using rule 67 (list_array -> ID .)
    SEMICOLON       reduce using rule 67 (list_array -> ID .)
    PLUS            reduce using rule 67 (list_array -> ID .)
    MINUS           reduce using rule 67 (list_array -> ID .)
    TIMES           reduce using rule 67 (list_array -> ID .)
    DIVIDE          reduce using rule 67 (list_array -> ID .)
    MOD             reduce using rule 67 (list_array -> ID .)
    COMPARASION     reduce using rule 67 (list_array -> ID .)
    DIFFERENT       reduce using rule 67 (list_array -> ID .)
    GREATER         reduce using rule 67 (list_array -> ID .)
    LESS            reduce using rule 67 (list_array -> ID .)
    GREATER_EQUAL   reduce using rule 67 (list_array -> ID .)
    LESS_EQUAL      reduce using rule 67 (list_array -> ID .)
    AND             reduce using rule 67 (list_array -> ID .)
    OR              reduce using rule 67 (list_array -> ID .)
    QUESTION        reduce using rule 67 (list_array -> ID .)
    RPAREN          reduce using rule 67 (list_array -> ID .)
    COLON           reduce using rule 67 (list_array -> ID .)
    RBRACKET        reduce using rule 67 (list_array -> ID .)
    COMMA           reduce using rule 67 (list_array -> ID .)

  ! DOT             [ reduce using rule 67 (list_array -> ID .) ]


state 55

    (30) print -> CONSOLE DOT . LOG LPAREN exp_list RPAREN SEMICOLON

    LOG             shift and go to state 90


state 56

    (34) declaration -> VAR ID COLON . type EQUAL exp
    (36) declaration -> VAR ID COLON . type
    (41) type -> . TYPES

    TYPES           shift and go to state 92

    type                           shift and go to state 91

state 57

    (35) declaration -> VAR ID EQUAL . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 93
    list_array                     shift and go to state 52

state 58

    (37) declaration -> VAR error SEMICOLON .

    SEMICOLON       reduce using rule 37 (declaration -> VAR error SEMICOLON .)
    RPAREN          reduce using rule 37 (declaration -> VAR error SEMICOLON .)


state 59

    (38) assignment -> ID EQUAL exp . SEMICOLON
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       shift and go to state 94
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 60

    (39) assignment -> ID PLUS_EQUAL exp . SEMICOLON
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       shift and go to state 95
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 61

    (40) assignment -> ID MINUS_EQUAL exp . SEMICOLON
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       shift and go to state 96
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 62

    (28) assignment_const -> CONST ID COLON . type EQUAL exp
    (41) type -> . TYPES

    TYPES           shift and go to state 92

    type                           shift and go to state 97

state 63

    (29) assignment_const -> CONST ID EQUAL . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 98
    list_array                     shift and go to state 52

state 64

    (31) interface -> INTERFACE ID LBRACE . interface_body RBRACE
    (32) interface_body -> . interface_body SEMICOLON ID COLON type
    (33) interface_body -> . ID COLON type

    ID              shift and go to state 99

    interface_body                 shift and go to state 100

state 65

    (16) if -> IF LPAREN exp . RPAREN block
    (17) if -> IF LPAREN exp . RPAREN block ELSE block
    (18) if -> IF LPAREN exp . RPAREN block ELSE if
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    RPAREN          shift and go to state 101
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 66

    (20) while -> WHILE LPAREN exp . RPAREN block
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    RPAREN          shift and go to state 102
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 67

    (21) for -> FOR LPAREN declaration . SEMICOLON exp SEMICOLON declaration RPAREN block

    SEMICOLON       shift and go to state 103


state 68

    (22) foreach -> FOR LPAREN VAR . ID OF ID RPAREN block
    (34) declaration -> VAR . ID COLON type EQUAL exp
    (35) declaration -> VAR . ID EQUAL exp
    (36) declaration -> VAR . ID COLON type
    (37) declaration -> VAR . error SEMICOLON

    ID              shift and go to state 104
    error           shift and go to state 31


state 69

    (25) return -> RETURN exp SEMICOLON .

    VAR             reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    CONST           reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    INTERFACE       reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    IF              reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    CONTINUE        reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    CONSOLE         reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    $end            reduce using rule 25 (return -> RETURN exp SEMICOLON .)
    RBRACE          reduce using rule 25 (return -> RETURN exp SEMICOLON .)


state 70

    (44) exp -> exp PLUS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 105
    list_array                     shift and go to state 52

state 71

    (45) exp -> exp MINUS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 106
    list_array                     shift and go to state 52

state 72

    (46) exp -> exp TIMES . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 107
    list_array                     shift and go to state 52

state 73

    (47) exp -> exp DIVIDE . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 108
    list_array                     shift and go to state 52

state 74

    (48) exp -> exp MOD . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 109
    list_array                     shift and go to state 52

state 75

    (51) exp -> exp COMPARASION . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 110
    list_array                     shift and go to state 52

state 76

    (52) exp -> exp DIFFERENT . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 111
    list_array                     shift and go to state 52

state 77

    (53) exp -> exp GREATER . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 112
    list_array                     shift and go to state 52

state 78

    (54) exp -> exp LESS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 113
    list_array                     shift and go to state 52

state 79

    (55) exp -> exp GREATER_EQUAL . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 114
    list_array                     shift and go to state 52

state 80

    (56) exp -> exp LESS_EQUAL . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 115
    list_array                     shift and go to state 52

state 81

    (57) exp -> exp AND . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 116
    list_array                     shift and go to state 52

state 82

    (58) exp -> exp OR . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 117
    list_array                     shift and go to state 52

state 83

    (69) exp -> exp QUESTION . exp COLON exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 118
    list_array                     shift and go to state 52

state 84

    (49) exp -> MINUS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 49 (exp -> MINUS exp .)
    PLUS            reduce using rule 49 (exp -> MINUS exp .)
    MINUS           reduce using rule 49 (exp -> MINUS exp .)
    TIMES           reduce using rule 49 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 49 (exp -> MINUS exp .)
    MOD             reduce using rule 49 (exp -> MINUS exp .)
    COMPARASION     reduce using rule 49 (exp -> MINUS exp .)
    DIFFERENT       reduce using rule 49 (exp -> MINUS exp .)
    GREATER         reduce using rule 49 (exp -> MINUS exp .)
    LESS            reduce using rule 49 (exp -> MINUS exp .)
    GREATER_EQUAL   reduce using rule 49 (exp -> MINUS exp .)
    LESS_EQUAL      reduce using rule 49 (exp -> MINUS exp .)
    AND             reduce using rule 49 (exp -> MINUS exp .)
    OR              reduce using rule 49 (exp -> MINUS exp .)
    QUESTION        reduce using rule 49 (exp -> MINUS exp .)
    RPAREN          reduce using rule 49 (exp -> MINUS exp .)
    COLON           reduce using rule 49 (exp -> MINUS exp .)
    RBRACKET        reduce using rule 49 (exp -> MINUS exp .)
    COMMA           reduce using rule 49 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 70 ]
  ! MINUS           [ shift and go to state 71 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 73 ]
  ! MOD             [ shift and go to state 74 ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 85

    (50) exp -> NOT exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 50 (exp -> NOT exp .)
    PLUS            reduce using rule 50 (exp -> NOT exp .)
    MINUS           reduce using rule 50 (exp -> NOT exp .)
    TIMES           reduce using rule 50 (exp -> NOT exp .)
    DIVIDE          reduce using rule 50 (exp -> NOT exp .)
    MOD             reduce using rule 50 (exp -> NOT exp .)
    COMPARASION     reduce using rule 50 (exp -> NOT exp .)
    DIFFERENT       reduce using rule 50 (exp -> NOT exp .)
    GREATER         reduce using rule 50 (exp -> NOT exp .)
    LESS            reduce using rule 50 (exp -> NOT exp .)
    GREATER_EQUAL   reduce using rule 50 (exp -> NOT exp .)
    LESS_EQUAL      reduce using rule 50 (exp -> NOT exp .)
    AND             reduce using rule 50 (exp -> NOT exp .)
    OR              reduce using rule 50 (exp -> NOT exp .)
    QUESTION        reduce using rule 50 (exp -> NOT exp .)
    RPAREN          reduce using rule 50 (exp -> NOT exp .)
    COLON           reduce using rule 50 (exp -> NOT exp .)
    RBRACKET        reduce using rule 50 (exp -> NOT exp .)
    COMMA           reduce using rule 50 (exp -> NOT exp .)

  ! PLUS            [ shift and go to state 70 ]
  ! MINUS           [ shift and go to state 71 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 73 ]
  ! MOD             [ shift and go to state 74 ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 86

    (65) list_array -> list_array LBRACKET . exp RBRACKET
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    list_array                     shift and go to state 52
    exp                            shift and go to state 119

state 87

    (66) list_array -> list_array DOT . ID

    ID              shift and go to state 120


state 88

    (68) exp -> LPAREN exp . RPAREN
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    RPAREN          shift and go to state 121
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 89

    (70) exp -> ID DOT . ID

    ID              shift and go to state 122


state 90

    (30) print -> CONSOLE DOT LOG . LPAREN exp_list RPAREN SEMICOLON

    LPAREN          shift and go to state 123


state 91

    (34) declaration -> VAR ID COLON type . EQUAL exp
    (36) declaration -> VAR ID COLON type .

    EQUAL           shift and go to state 124
    SEMICOLON       reduce using rule 36 (declaration -> VAR ID COLON type .)
    RPAREN          reduce using rule 36 (declaration -> VAR ID COLON type .)


state 92

    (41) type -> TYPES .

    EQUAL           reduce using rule 41 (type -> TYPES .)
    SEMICOLON       reduce using rule 41 (type -> TYPES .)
    RPAREN          reduce using rule 41 (type -> TYPES .)
    RBRACE          reduce using rule 41 (type -> TYPES .)


state 93

    (35) declaration -> VAR ID EQUAL exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 35 (declaration -> VAR ID EQUAL exp .)
    RPAREN          reduce using rule 35 (declaration -> VAR ID EQUAL exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 94

    (38) assignment -> ID EQUAL exp SEMICOLON .

    VAR             reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    CONST           reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    ID              reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    INTERFACE       reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    IF              reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    FOR             reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    BREAK           reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    CONTINUE        reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    CONSOLE         reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    $end            reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 38 (assignment -> ID EQUAL exp SEMICOLON .)


state 95

    (39) assignment -> ID PLUS_EQUAL exp SEMICOLON .

    VAR             reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    CONST           reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    ID              reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    INTERFACE       reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    IF              reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    FOR             reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    BREAK           reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    CONTINUE        reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    CONSOLE         reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    $end            reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 39 (assignment -> ID PLUS_EQUAL exp SEMICOLON .)


state 96

    (40) assignment -> ID MINUS_EQUAL exp SEMICOLON .

    VAR             reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    CONST           reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    ID              reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    INTERFACE       reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    IF              reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    FOR             reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    BREAK           reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    CONTINUE        reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    CONSOLE         reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    $end            reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 40 (assignment -> ID MINUS_EQUAL exp SEMICOLON .)


state 97

    (28) assignment_const -> CONST ID COLON type . EQUAL exp

    EQUAL           shift and go to state 125


state 98

    (29) assignment_const -> CONST ID EQUAL exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 29 (assignment_const -> CONST ID EQUAL exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 99

    (33) interface_body -> ID . COLON type

    COLON           shift and go to state 126


state 100

    (31) interface -> INTERFACE ID LBRACE interface_body . RBRACE
    (32) interface_body -> interface_body . SEMICOLON ID COLON type

    RBRACE          shift and go to state 127
    SEMICOLON       shift and go to state 128


state 101

    (16) if -> IF LPAREN exp RPAREN . block
    (17) if -> IF LPAREN exp RPAREN . block ELSE block
    (18) if -> IF LPAREN exp RPAREN . block ELSE if
    (27) block -> . LBRACE init RBRACE

    LBRACE          shift and go to state 130

    block                          shift and go to state 129

state 102

    (20) while -> WHILE LPAREN exp RPAREN . block
    (27) block -> . LBRACE init RBRACE

    LBRACE          shift and go to state 130

    block                          shift and go to state 131

state 103

    (21) for -> FOR LPAREN declaration SEMICOLON . exp SEMICOLON declaration RPAREN block
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 132
    list_array                     shift and go to state 52

state 104

    (22) foreach -> FOR LPAREN VAR ID . OF ID RPAREN block
    (34) declaration -> VAR ID . COLON type EQUAL exp
    (35) declaration -> VAR ID . EQUAL exp
    (36) declaration -> VAR ID . COLON type

    OF              shift and go to state 133
    COLON           shift and go to state 56
    EQUAL           shift and go to state 57


state 105

    (44) exp -> exp PLUS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 44 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 44 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 44 (exp -> exp PLUS exp .)
    COMPARASION     reduce using rule 44 (exp -> exp PLUS exp .)
    DIFFERENT       reduce using rule 44 (exp -> exp PLUS exp .)
    GREATER         reduce using rule 44 (exp -> exp PLUS exp .)
    LESS            reduce using rule 44 (exp -> exp PLUS exp .)
    GREATER_EQUAL   reduce using rule 44 (exp -> exp PLUS exp .)
    LESS_EQUAL      reduce using rule 44 (exp -> exp PLUS exp .)
    AND             reduce using rule 44 (exp -> exp PLUS exp .)
    OR              reduce using rule 44 (exp -> exp PLUS exp .)
    QUESTION        reduce using rule 44 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 44 (exp -> exp PLUS exp .)
    COLON           reduce using rule 44 (exp -> exp PLUS exp .)
    RBRACKET        reduce using rule 44 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 44 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74

  ! TIMES           [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 70 ]
  ! MINUS           [ shift and go to state 71 ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 106

    (45) exp -> exp MINUS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 45 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 45 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 45 (exp -> exp MINUS exp .)
    COMPARASION     reduce using rule 45 (exp -> exp MINUS exp .)
    DIFFERENT       reduce using rule 45 (exp -> exp MINUS exp .)
    GREATER         reduce using rule 45 (exp -> exp MINUS exp .)
    LESS            reduce using rule 45 (exp -> exp MINUS exp .)
    GREATER_EQUAL   reduce using rule 45 (exp -> exp MINUS exp .)
    LESS_EQUAL      reduce using rule 45 (exp -> exp MINUS exp .)
    AND             reduce using rule 45 (exp -> exp MINUS exp .)
    OR              reduce using rule 45 (exp -> exp MINUS exp .)
    QUESTION        reduce using rule 45 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 45 (exp -> exp MINUS exp .)
    COLON           reduce using rule 45 (exp -> exp MINUS exp .)
    RBRACKET        reduce using rule 45 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 45 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74

  ! TIMES           [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 70 ]
  ! MINUS           [ shift and go to state 71 ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 107

    (46) exp -> exp TIMES exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 46 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 46 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 46 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 46 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 46 (exp -> exp TIMES exp .)
    MOD             reduce using rule 46 (exp -> exp TIMES exp .)
    COMPARASION     reduce using rule 46 (exp -> exp TIMES exp .)
    DIFFERENT       reduce using rule 46 (exp -> exp TIMES exp .)
    GREATER         reduce using rule 46 (exp -> exp TIMES exp .)
    LESS            reduce using rule 46 (exp -> exp TIMES exp .)
    GREATER_EQUAL   reduce using rule 46 (exp -> exp TIMES exp .)
    LESS_EQUAL      reduce using rule 46 (exp -> exp TIMES exp .)
    AND             reduce using rule 46 (exp -> exp TIMES exp .)
    OR              reduce using rule 46 (exp -> exp TIMES exp .)
    QUESTION        reduce using rule 46 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 46 (exp -> exp TIMES exp .)
    COLON           reduce using rule 46 (exp -> exp TIMES exp .)
    RBRACKET        reduce using rule 46 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 46 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 70 ]
  ! MINUS           [ shift and go to state 71 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 73 ]
  ! MOD             [ shift and go to state 74 ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 108

    (47) exp -> exp DIVIDE exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 47 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 47 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 47 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 47 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 47 (exp -> exp DIVIDE exp .)
    MOD             reduce using rule 47 (exp -> exp DIVIDE exp .)
    COMPARASION     reduce using rule 47 (exp -> exp DIVIDE exp .)
    DIFFERENT       reduce using rule 47 (exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 47 (exp -> exp DIVIDE exp .)
    LESS            reduce using rule 47 (exp -> exp DIVIDE exp .)
    GREATER_EQUAL   reduce using rule 47 (exp -> exp DIVIDE exp .)
    LESS_EQUAL      reduce using rule 47 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 47 (exp -> exp DIVIDE exp .)
    OR              reduce using rule 47 (exp -> exp DIVIDE exp .)
    QUESTION        reduce using rule 47 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 47 (exp -> exp DIVIDE exp .)
    COLON           reduce using rule 47 (exp -> exp DIVIDE exp .)
    RBRACKET        reduce using rule 47 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 47 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 70 ]
  ! MINUS           [ shift and go to state 71 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 73 ]
  ! MOD             [ shift and go to state 74 ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 109

    (48) exp -> exp MOD exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 48 (exp -> exp MOD exp .)
    PLUS            reduce using rule 48 (exp -> exp MOD exp .)
    MINUS           reduce using rule 48 (exp -> exp MOD exp .)
    TIMES           reduce using rule 48 (exp -> exp MOD exp .)
    DIVIDE          reduce using rule 48 (exp -> exp MOD exp .)
    MOD             reduce using rule 48 (exp -> exp MOD exp .)
    COMPARASION     reduce using rule 48 (exp -> exp MOD exp .)
    DIFFERENT       reduce using rule 48 (exp -> exp MOD exp .)
    GREATER         reduce using rule 48 (exp -> exp MOD exp .)
    LESS            reduce using rule 48 (exp -> exp MOD exp .)
    GREATER_EQUAL   reduce using rule 48 (exp -> exp MOD exp .)
    LESS_EQUAL      reduce using rule 48 (exp -> exp MOD exp .)
    AND             reduce using rule 48 (exp -> exp MOD exp .)
    OR              reduce using rule 48 (exp -> exp MOD exp .)
    QUESTION        reduce using rule 48 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 48 (exp -> exp MOD exp .)
    COLON           reduce using rule 48 (exp -> exp MOD exp .)
    RBRACKET        reduce using rule 48 (exp -> exp MOD exp .)
    COMMA           reduce using rule 48 (exp -> exp MOD exp .)

  ! PLUS            [ shift and go to state 70 ]
  ! MINUS           [ shift and go to state 71 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 73 ]
  ! MOD             [ shift and go to state 74 ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 110

    (51) exp -> exp COMPARASION exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 51 (exp -> exp COMPARASION exp .)
    COMPARASION     reduce using rule 51 (exp -> exp COMPARASION exp .)
    DIFFERENT       reduce using rule 51 (exp -> exp COMPARASION exp .)
    AND             reduce using rule 51 (exp -> exp COMPARASION exp .)
    OR              reduce using rule 51 (exp -> exp COMPARASION exp .)
    QUESTION        reduce using rule 51 (exp -> exp COMPARASION exp .)
    RPAREN          reduce using rule 51 (exp -> exp COMPARASION exp .)
    COLON           reduce using rule 51 (exp -> exp COMPARASION exp .)
    RBRACKET        reduce using rule 51 (exp -> exp COMPARASION exp .)
    COMMA           reduce using rule 51 (exp -> exp COMPARASION exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80

  ! PLUS            [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! MINUS           [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! TIMES           [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! MOD             [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! GREATER         [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! LESS            [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! LESS_EQUAL      [ reduce using rule 51 (exp -> exp COMPARASION exp .) ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 111

    (52) exp -> exp DIFFERENT exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 52 (exp -> exp DIFFERENT exp .)
    COMPARASION     reduce using rule 52 (exp -> exp DIFFERENT exp .)
    DIFFERENT       reduce using rule 52 (exp -> exp DIFFERENT exp .)
    AND             reduce using rule 52 (exp -> exp DIFFERENT exp .)
    OR              reduce using rule 52 (exp -> exp DIFFERENT exp .)
    QUESTION        reduce using rule 52 (exp -> exp DIFFERENT exp .)
    RPAREN          reduce using rule 52 (exp -> exp DIFFERENT exp .)
    COLON           reduce using rule 52 (exp -> exp DIFFERENT exp .)
    RBRACKET        reduce using rule 52 (exp -> exp DIFFERENT exp .)
    COMMA           reduce using rule 52 (exp -> exp DIFFERENT exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80

  ! PLUS            [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! TIMES           [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! MOD             [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! GREATER         [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! LESS            [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! LESS_EQUAL      [ reduce using rule 52 (exp -> exp DIFFERENT exp .) ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 112

    (53) exp -> exp GREATER exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 53 (exp -> exp GREATER exp .)
    COMPARASION     reduce using rule 53 (exp -> exp GREATER exp .)
    DIFFERENT       reduce using rule 53 (exp -> exp GREATER exp .)
    GREATER         reduce using rule 53 (exp -> exp GREATER exp .)
    LESS            reduce using rule 53 (exp -> exp GREATER exp .)
    GREATER_EQUAL   reduce using rule 53 (exp -> exp GREATER exp .)
    LESS_EQUAL      reduce using rule 53 (exp -> exp GREATER exp .)
    AND             reduce using rule 53 (exp -> exp GREATER exp .)
    OR              reduce using rule 53 (exp -> exp GREATER exp .)
    QUESTION        reduce using rule 53 (exp -> exp GREATER exp .)
    RPAREN          reduce using rule 53 (exp -> exp GREATER exp .)
    COLON           reduce using rule 53 (exp -> exp GREATER exp .)
    RBRACKET        reduce using rule 53 (exp -> exp GREATER exp .)
    COMMA           reduce using rule 53 (exp -> exp GREATER exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74

  ! PLUS            [ reduce using rule 53 (exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 53 (exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 53 (exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 53 (exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 53 (exp -> exp GREATER exp .) ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 113

    (54) exp -> exp LESS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 54 (exp -> exp LESS exp .)
    COMPARASION     reduce using rule 54 (exp -> exp LESS exp .)
    DIFFERENT       reduce using rule 54 (exp -> exp LESS exp .)
    GREATER         reduce using rule 54 (exp -> exp LESS exp .)
    LESS            reduce using rule 54 (exp -> exp LESS exp .)
    GREATER_EQUAL   reduce using rule 54 (exp -> exp LESS exp .)
    LESS_EQUAL      reduce using rule 54 (exp -> exp LESS exp .)
    AND             reduce using rule 54 (exp -> exp LESS exp .)
    OR              reduce using rule 54 (exp -> exp LESS exp .)
    QUESTION        reduce using rule 54 (exp -> exp LESS exp .)
    RPAREN          reduce using rule 54 (exp -> exp LESS exp .)
    COLON           reduce using rule 54 (exp -> exp LESS exp .)
    RBRACKET        reduce using rule 54 (exp -> exp LESS exp .)
    COMMA           reduce using rule 54 (exp -> exp LESS exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74

  ! PLUS            [ reduce using rule 54 (exp -> exp LESS exp .) ]
  ! MINUS           [ reduce using rule 54 (exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 54 (exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> exp LESS exp .) ]
  ! MOD             [ reduce using rule 54 (exp -> exp LESS exp .) ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 114

    (55) exp -> exp GREATER_EQUAL exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    COMPARASION     reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    DIFFERENT       reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    GREATER         reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    LESS            reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    LESS_EQUAL      reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    AND             reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    OR              reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    QUESTION        reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    RPAREN          reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    COLON           reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    RBRACKET        reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    COMMA           reduce using rule 55 (exp -> exp GREATER_EQUAL exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74

  ! PLUS            [ reduce using rule 55 (exp -> exp GREATER_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 55 (exp -> exp GREATER_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 55 (exp -> exp GREATER_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> exp GREATER_EQUAL exp .) ]
  ! MOD             [ reduce using rule 55 (exp -> exp GREATER_EQUAL exp .) ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 115

    (56) exp -> exp LESS_EQUAL exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    COMPARASION     reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    DIFFERENT       reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    GREATER         reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    LESS            reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    LESS_EQUAL      reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    AND             reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    OR              reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    QUESTION        reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    RPAREN          reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    COLON           reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    RBRACKET        reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    COMMA           reduce using rule 56 (exp -> exp LESS_EQUAL exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74

  ! PLUS            [ reduce using rule 56 (exp -> exp LESS_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> exp LESS_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 56 (exp -> exp LESS_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> exp LESS_EQUAL exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> exp LESS_EQUAL exp .) ]
  ! COMPARASION     [ shift and go to state 75 ]
  ! DIFFERENT       [ shift and go to state 76 ]
  ! GREATER         [ shift and go to state 77 ]
  ! LESS            [ shift and go to state 78 ]
  ! GREATER_EQUAL   [ shift and go to state 79 ]
  ! LESS_EQUAL      [ shift and go to state 80 ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 116

    (57) exp -> exp AND exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 57 (exp -> exp AND exp .)
    AND             reduce using rule 57 (exp -> exp AND exp .)
    OR              reduce using rule 57 (exp -> exp AND exp .)
    QUESTION        reduce using rule 57 (exp -> exp AND exp .)
    RPAREN          reduce using rule 57 (exp -> exp AND exp .)
    COLON           reduce using rule 57 (exp -> exp AND exp .)
    RBRACKET        reduce using rule 57 (exp -> exp AND exp .)
    COMMA           reduce using rule 57 (exp -> exp AND exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80

  ! PLUS            [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! COMPARASION     [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! DIFFERENT       [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! GREATER         [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! LESS            [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! LESS_EQUAL      [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 81 ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 117

    (58) exp -> exp OR exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 58 (exp -> exp OR exp .)
    OR              reduce using rule 58 (exp -> exp OR exp .)
    QUESTION        reduce using rule 58 (exp -> exp OR exp .)
    RPAREN          reduce using rule 58 (exp -> exp OR exp .)
    COLON           reduce using rule 58 (exp -> exp OR exp .)
    RBRACKET        reduce using rule 58 (exp -> exp OR exp .)
    COMMA           reduce using rule 58 (exp -> exp OR exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81

  ! PLUS            [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! COMPARASION     [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! DIFFERENT       [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! GREATER         [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! LESS            [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! LESS_EQUAL      [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 82 ]
  ! QUESTION        [ shift and go to state 83 ]


state 118

    (69) exp -> exp QUESTION exp . COLON exp
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    COLON           shift and go to state 134
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 119

    (65) list_array -> list_array LBRACKET exp . RBRACKET
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    RBRACKET        shift and go to state 135
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 120

    (66) list_array -> list_array DOT ID .

    LBRACKET        reduce using rule 66 (list_array -> list_array DOT ID .)
    DOT             reduce using rule 66 (list_array -> list_array DOT ID .)
    SEMICOLON       reduce using rule 66 (list_array -> list_array DOT ID .)
    PLUS            reduce using rule 66 (list_array -> list_array DOT ID .)
    MINUS           reduce using rule 66 (list_array -> list_array DOT ID .)
    TIMES           reduce using rule 66 (list_array -> list_array DOT ID .)
    DIVIDE          reduce using rule 66 (list_array -> list_array DOT ID .)
    MOD             reduce using rule 66 (list_array -> list_array DOT ID .)
    COMPARASION     reduce using rule 66 (list_array -> list_array DOT ID .)
    DIFFERENT       reduce using rule 66 (list_array -> list_array DOT ID .)
    GREATER         reduce using rule 66 (list_array -> list_array DOT ID .)
    LESS            reduce using rule 66 (list_array -> list_array DOT ID .)
    GREATER_EQUAL   reduce using rule 66 (list_array -> list_array DOT ID .)
    LESS_EQUAL      reduce using rule 66 (list_array -> list_array DOT ID .)
    AND             reduce using rule 66 (list_array -> list_array DOT ID .)
    OR              reduce using rule 66 (list_array -> list_array DOT ID .)
    QUESTION        reduce using rule 66 (list_array -> list_array DOT ID .)
    RPAREN          reduce using rule 66 (list_array -> list_array DOT ID .)
    COLON           reduce using rule 66 (list_array -> list_array DOT ID .)
    RBRACKET        reduce using rule 66 (list_array -> list_array DOT ID .)
    COMMA           reduce using rule 66 (list_array -> list_array DOT ID .)


state 121

    (68) exp -> LPAREN exp RPAREN .

    SEMICOLON       reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    COMPARASION     reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    DIFFERENT       reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    GREATER         reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    LESS            reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    GREATER_EQUAL   reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    LESS_EQUAL      reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    QUESTION        reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    COLON           reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 68 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 68 (exp -> LPAREN exp RPAREN .)


state 122

    (70) exp -> ID DOT ID .

    SEMICOLON       reduce using rule 70 (exp -> ID DOT ID .)
    PLUS            reduce using rule 70 (exp -> ID DOT ID .)
    MINUS           reduce using rule 70 (exp -> ID DOT ID .)
    TIMES           reduce using rule 70 (exp -> ID DOT ID .)
    DIVIDE          reduce using rule 70 (exp -> ID DOT ID .)
    MOD             reduce using rule 70 (exp -> ID DOT ID .)
    COMPARASION     reduce using rule 70 (exp -> ID DOT ID .)
    DIFFERENT       reduce using rule 70 (exp -> ID DOT ID .)
    GREATER         reduce using rule 70 (exp -> ID DOT ID .)
    LESS            reduce using rule 70 (exp -> ID DOT ID .)
    GREATER_EQUAL   reduce using rule 70 (exp -> ID DOT ID .)
    LESS_EQUAL      reduce using rule 70 (exp -> ID DOT ID .)
    AND             reduce using rule 70 (exp -> ID DOT ID .)
    OR              reduce using rule 70 (exp -> ID DOT ID .)
    QUESTION        reduce using rule 70 (exp -> ID DOT ID .)
    RPAREN          reduce using rule 70 (exp -> ID DOT ID .)
    COLON           reduce using rule 70 (exp -> ID DOT ID .)
    RBRACKET        reduce using rule 70 (exp -> ID DOT ID .)
    COMMA           reduce using rule 70 (exp -> ID DOT ID .)


state 123

    (30) print -> CONSOLE DOT LOG LPAREN . exp_list RPAREN SEMICOLON
    (42) exp_list -> . exp_list COMMA exp
    (43) exp_list -> . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp_list                       shift and go to state 136
    exp                            shift and go to state 137
    list_array                     shift and go to state 52

state 124

    (34) declaration -> VAR ID COLON type EQUAL . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 138
    list_array                     shift and go to state 52

state 125

    (28) assignment_const -> CONST ID COLON type EQUAL . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 139
    list_array                     shift and go to state 52

state 126

    (33) interface_body -> ID COLON . type
    (41) type -> . TYPES

    TYPES           shift and go to state 92

    type                           shift and go to state 140

state 127

    (31) interface -> INTERFACE ID LBRACE interface_body RBRACE .

    VAR             reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    CONST           reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    ID              reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    INTERFACE       reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    IF              reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    WHILE           reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    FOR             reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    BREAK           reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    CONTINUE        reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    RETURN          reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    CONSOLE         reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    $end            reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)
    RBRACE          reduce using rule 31 (interface -> INTERFACE ID LBRACE interface_body RBRACE .)


state 128

    (32) interface_body -> interface_body SEMICOLON . ID COLON type

    ID              shift and go to state 141


state 129

    (16) if -> IF LPAREN exp RPAREN block .
    (17) if -> IF LPAREN exp RPAREN block . ELSE block
    (18) if -> IF LPAREN exp RPAREN block . ELSE if

    VAR             reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    CONST           reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    ID              reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    INTERFACE       reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    IF              reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    WHILE           reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    FOR             reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    BREAK           reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    CONTINUE        reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    RETURN          reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    CONSOLE         reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    $end            reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    RBRACE          reduce using rule 16 (if -> IF LPAREN exp RPAREN block .)
    ELSE            shift and go to state 142


state 130

    (27) block -> LBRACE . init RBRACE
    (2) init -> . init instruction
    (3) init -> . instruction
    (4) instruction -> . declaration SEMICOLON
    (5) instruction -> . assignment_const SEMICOLON
    (6) instruction -> . assignment
    (7) instruction -> . interface
    (8) instruction -> . if
    (9) instruction -> . while
    (10) instruction -> . for
    (11) instruction -> . foreach
    (12) instruction -> . break
    (13) instruction -> . continue
    (14) instruction -> . return
    (15) instruction -> . print
    (34) declaration -> . VAR ID COLON type EQUAL exp
    (35) declaration -> . VAR ID EQUAL exp
    (36) declaration -> . VAR ID COLON type
    (37) declaration -> . VAR error SEMICOLON
    (28) assignment_const -> . CONST ID COLON type EQUAL exp
    (29) assignment_const -> . CONST ID EQUAL exp
    (38) assignment -> . ID EQUAL exp SEMICOLON
    (39) assignment -> . ID PLUS_EQUAL exp SEMICOLON
    (40) assignment -> . ID MINUS_EQUAL exp SEMICOLON
    (31) interface -> . INTERFACE ID LBRACE interface_body RBRACE
    (16) if -> . IF LPAREN exp RPAREN block
    (17) if -> . IF LPAREN exp RPAREN block ELSE block
    (18) if -> . IF LPAREN exp RPAREN block ELSE if
    (19) if -> . IF error
    (20) while -> . WHILE LPAREN exp RPAREN block
    (21) for -> . FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block
    (22) foreach -> . FOR LPAREN VAR ID OF ID RPAREN block
    (23) break -> . BREAK SEMICOLON
    (24) continue -> . CONTINUE SEMICOLON
    (25) return -> . RETURN exp SEMICOLON
    (26) return -> . RETURN SEMICOLON
    (30) print -> . CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON

    VAR             shift and go to state 16
    CONST           shift and go to state 18
    ID              shift and go to state 17
    INTERFACE       shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    RETURN          shift and go to state 25
    CONSOLE         shift and go to state 26

    init                           shift and go to state 143
    instruction                    shift and go to state 3
    declaration                    shift and go to state 4
    assignment_const               shift and go to state 5
    assignment                     shift and go to state 6
    interface                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    foreach                        shift and go to state 11
    break                          shift and go to state 12
    continue                       shift and go to state 13
    return                         shift and go to state 14
    print                          shift and go to state 15

state 131

    (20) while -> WHILE LPAREN exp RPAREN block .

    VAR             reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    CONST           reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    ID              reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    INTERFACE       reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    IF              reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    WHILE           reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    FOR             reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    BREAK           reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    CONTINUE        reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    RETURN          reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    CONSOLE         reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    $end            reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)
    RBRACE          reduce using rule 20 (while -> WHILE LPAREN exp RPAREN block .)


state 132

    (21) for -> FOR LPAREN declaration SEMICOLON exp . SEMICOLON declaration RPAREN block
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       shift and go to state 144
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 133

    (22) foreach -> FOR LPAREN VAR ID OF . ID RPAREN block

    ID              shift and go to state 145


state 134

    (69) exp -> exp QUESTION exp COLON . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 146
    list_array                     shift and go to state 52

state 135

    (65) list_array -> list_array LBRACKET exp RBRACKET .

    LBRACKET        reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    DOT             reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    MOD             reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    COMPARASION     reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    DIFFERENT       reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    GREATER         reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    LESS            reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    LESS_EQUAL      reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    AND             reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    OR              reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    QUESTION        reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    COLON           reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 65 (list_array -> list_array LBRACKET exp RBRACKET .)


state 136

    (30) print -> CONSOLE DOT LOG LPAREN exp_list . RPAREN SEMICOLON
    (42) exp_list -> exp_list . COMMA exp

    RPAREN          shift and go to state 147
    COMMA           shift and go to state 148


state 137

    (43) exp_list -> exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    RPAREN          reduce using rule 43 (exp_list -> exp .)
    COMMA           reduce using rule 43 (exp_list -> exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 138

    (34) declaration -> VAR ID COLON type EQUAL exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 34 (declaration -> VAR ID COLON type EQUAL exp .)
    RPAREN          reduce using rule 34 (declaration -> VAR ID COLON type EQUAL exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 139

    (28) assignment_const -> CONST ID COLON type EQUAL exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    SEMICOLON       reduce using rule 28 (assignment_const -> CONST ID COLON type EQUAL exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 140

    (33) interface_body -> ID COLON type .

    RBRACE          reduce using rule 33 (interface_body -> ID COLON type .)
    SEMICOLON       reduce using rule 33 (interface_body -> ID COLON type .)


state 141

    (32) interface_body -> interface_body SEMICOLON ID . COLON type

    COLON           shift and go to state 149


state 142

    (17) if -> IF LPAREN exp RPAREN block ELSE . block
    (18) if -> IF LPAREN exp RPAREN block ELSE . if
    (27) block -> . LBRACE init RBRACE
    (16) if -> . IF LPAREN exp RPAREN block
    (17) if -> . IF LPAREN exp RPAREN block ELSE block
    (18) if -> . IF LPAREN exp RPAREN block ELSE if
    (19) if -> . IF error

    LBRACE          shift and go to state 130
    IF              shift and go to state 20

    block                          shift and go to state 150
    if                             shift and go to state 151

state 143

    (27) block -> LBRACE init . RBRACE
    (2) init -> init . instruction
    (4) instruction -> . declaration SEMICOLON
    (5) instruction -> . assignment_const SEMICOLON
    (6) instruction -> . assignment
    (7) instruction -> . interface
    (8) instruction -> . if
    (9) instruction -> . while
    (10) instruction -> . for
    (11) instruction -> . foreach
    (12) instruction -> . break
    (13) instruction -> . continue
    (14) instruction -> . return
    (15) instruction -> . print
    (34) declaration -> . VAR ID COLON type EQUAL exp
    (35) declaration -> . VAR ID EQUAL exp
    (36) declaration -> . VAR ID COLON type
    (37) declaration -> . VAR error SEMICOLON
    (28) assignment_const -> . CONST ID COLON type EQUAL exp
    (29) assignment_const -> . CONST ID EQUAL exp
    (38) assignment -> . ID EQUAL exp SEMICOLON
    (39) assignment -> . ID PLUS_EQUAL exp SEMICOLON
    (40) assignment -> . ID MINUS_EQUAL exp SEMICOLON
    (31) interface -> . INTERFACE ID LBRACE interface_body RBRACE
    (16) if -> . IF LPAREN exp RPAREN block
    (17) if -> . IF LPAREN exp RPAREN block ELSE block
    (18) if -> . IF LPAREN exp RPAREN block ELSE if
    (19) if -> . IF error
    (20) while -> . WHILE LPAREN exp RPAREN block
    (21) for -> . FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block
    (22) foreach -> . FOR LPAREN VAR ID OF ID RPAREN block
    (23) break -> . BREAK SEMICOLON
    (24) continue -> . CONTINUE SEMICOLON
    (25) return -> . RETURN exp SEMICOLON
    (26) return -> . RETURN SEMICOLON
    (30) print -> . CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON

    RBRACE          shift and go to state 152
    VAR             shift and go to state 16
    CONST           shift and go to state 18
    ID              shift and go to state 17
    INTERFACE       shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    BREAK           shift and go to state 23
    CONTINUE        shift and go to state 24
    RETURN          shift and go to state 25
    CONSOLE         shift and go to state 26

    instruction                    shift and go to state 27
    declaration                    shift and go to state 4
    assignment_const               shift and go to state 5
    assignment                     shift and go to state 6
    interface                      shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    foreach                        shift and go to state 11
    break                          shift and go to state 12
    continue                       shift and go to state 13
    return                         shift and go to state 14
    print                          shift and go to state 15

state 144

    (21) for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON . declaration RPAREN block
    (34) declaration -> . VAR ID COLON type EQUAL exp
    (35) declaration -> . VAR ID EQUAL exp
    (36) declaration -> . VAR ID COLON type
    (37) declaration -> . VAR error SEMICOLON

    VAR             shift and go to state 16

    declaration                    shift and go to state 153

state 145

    (22) foreach -> FOR LPAREN VAR ID OF ID . RPAREN block

    RPAREN          shift and go to state 154


state 146

    (69) exp -> exp QUESTION exp COLON exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for COMPARASION resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
    SEMICOLON       reduce using rule 69 (exp -> exp QUESTION exp COLON exp .)
    RPAREN          reduce using rule 69 (exp -> exp QUESTION exp COLON exp .)
    COLON           reduce using rule 69 (exp -> exp QUESTION exp COLON exp .)
    RBRACKET        reduce using rule 69 (exp -> exp QUESTION exp COLON exp .)
    COMMA           reduce using rule 69 (exp -> exp QUESTION exp COLON exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83

  ! PLUS            [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! MINUS           [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! TIMES           [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! DIVIDE          [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! MOD             [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! COMPARASION     [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! DIFFERENT       [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! GREATER         [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! LESS            [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! LESS_EQUAL      [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! AND             [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! OR              [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]
  ! QUESTION        [ reduce using rule 69 (exp -> exp QUESTION exp COLON exp .) ]


state 147

    (30) print -> CONSOLE DOT LOG LPAREN exp_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 155


state 148

    (42) exp_list -> exp_list COMMA . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp TIMES exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . MINUS exp
    (50) exp -> . NOT exp
    (51) exp -> . exp COMPARASION exp
    (52) exp -> . exp DIFFERENT exp
    (53) exp -> . exp GREATER exp
    (54) exp -> . exp LESS exp
    (55) exp -> . exp GREATER_EQUAL exp
    (56) exp -> . exp LESS_EQUAL exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . NUMBER_LEX
    (60) exp -> . FLOAT_LEX
    (61) exp -> . STRING_LEX
    (62) exp -> . CHAR_LEX
    (63) exp -> . BOOLEAN
    (64) exp -> . list_array
    (68) exp -> . LPAREN exp RPAREN
    (69) exp -> . exp QUESTION exp COLON exp
    (70) exp -> . ID DOT ID
    (65) list_array -> . list_array LBRACKET exp RBRACKET
    (66) list_array -> . list_array DOT ID
    (67) list_array -> . ID

    MINUS           shift and go to state 45
    NOT             shift and go to state 46
    NUMBER_LEX      shift and go to state 47
    FLOAT_LEX       shift and go to state 48
    STRING_LEX      shift and go to state 49
    CHAR_LEX        shift and go to state 50
    BOOLEAN         shift and go to state 51
    LPAREN          shift and go to state 53
    ID              shift and go to state 54

    exp                            shift and go to state 156
    list_array                     shift and go to state 52

state 149

    (32) interface_body -> interface_body SEMICOLON ID COLON . type
    (41) type -> . TYPES

    TYPES           shift and go to state 92

    type                           shift and go to state 157

state 150

    (17) if -> IF LPAREN exp RPAREN block ELSE block .

    VAR             reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    CONST           reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    ID              reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    INTERFACE       reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    IF              reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    WHILE           reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    FOR             reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    BREAK           reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    CONTINUE        reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    RETURN          reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    CONSOLE         reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    $end            reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)
    RBRACE          reduce using rule 17 (if -> IF LPAREN exp RPAREN block ELSE block .)


state 151

    (18) if -> IF LPAREN exp RPAREN block ELSE if .

    VAR             reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    CONST           reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    ID              reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    INTERFACE       reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    IF              reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    WHILE           reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    FOR             reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    BREAK           reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    CONTINUE        reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    RETURN          reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    CONSOLE         reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    $end            reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)
    RBRACE          reduce using rule 18 (if -> IF LPAREN exp RPAREN block ELSE if .)


state 152

    (27) block -> LBRACE init RBRACE .

    ELSE            reduce using rule 27 (block -> LBRACE init RBRACE .)
    VAR             reduce using rule 27 (block -> LBRACE init RBRACE .)
    CONST           reduce using rule 27 (block -> LBRACE init RBRACE .)
    ID              reduce using rule 27 (block -> LBRACE init RBRACE .)
    INTERFACE       reduce using rule 27 (block -> LBRACE init RBRACE .)
    IF              reduce using rule 27 (block -> LBRACE init RBRACE .)
    WHILE           reduce using rule 27 (block -> LBRACE init RBRACE .)
    FOR             reduce using rule 27 (block -> LBRACE init RBRACE .)
    BREAK           reduce using rule 27 (block -> LBRACE init RBRACE .)
    CONTINUE        reduce using rule 27 (block -> LBRACE init RBRACE .)
    RETURN          reduce using rule 27 (block -> LBRACE init RBRACE .)
    CONSOLE         reduce using rule 27 (block -> LBRACE init RBRACE .)
    $end            reduce using rule 27 (block -> LBRACE init RBRACE .)
    RBRACE          reduce using rule 27 (block -> LBRACE init RBRACE .)


state 153

    (21) for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration . RPAREN block

    RPAREN          shift and go to state 158


state 154

    (22) foreach -> FOR LPAREN VAR ID OF ID RPAREN . block
    (27) block -> . LBRACE init RBRACE

    LBRACE          shift and go to state 130

    block                          shift and go to state 159

state 155

    (30) print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .

    VAR             reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    CONST           reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    ID              reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    INTERFACE       reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    IF              reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    FOR             reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    BREAK           reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    CONSOLE         reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    $end            reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 30 (print -> CONSOLE DOT LOG LPAREN exp_list RPAREN SEMICOLON .)


state 156

    (42) exp_list -> exp_list COMMA exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . TIMES exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (51) exp -> exp . COMPARASION exp
    (52) exp -> exp . DIFFERENT exp
    (53) exp -> exp . GREATER exp
    (54) exp -> exp . LESS exp
    (55) exp -> exp . GREATER_EQUAL exp
    (56) exp -> exp . LESS_EQUAL exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (69) exp -> exp . QUESTION exp COLON exp

    RPAREN          reduce using rule 42 (exp_list -> exp_list COMMA exp .)
    COMMA           reduce using rule 42 (exp_list -> exp_list COMMA exp .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 73
    MOD             shift and go to state 74
    COMPARASION     shift and go to state 75
    DIFFERENT       shift and go to state 76
    GREATER         shift and go to state 77
    LESS            shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    QUESTION        shift and go to state 83


state 157

    (32) interface_body -> interface_body SEMICOLON ID COLON type .

    RBRACE          reduce using rule 32 (interface_body -> interface_body SEMICOLON ID COLON type .)
    SEMICOLON       reduce using rule 32 (interface_body -> interface_body SEMICOLON ID COLON type .)


state 158

    (21) for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN . block
    (27) block -> . LBRACE init RBRACE

    LBRACE          shift and go to state 130

    block                          shift and go to state 160

state 159

    (22) foreach -> FOR LPAREN VAR ID OF ID RPAREN block .

    VAR             reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    CONST           reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    ID              reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    INTERFACE       reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    IF              reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    WHILE           reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    FOR             reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    BREAK           reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    CONTINUE        reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    RETURN          reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    CONSOLE         reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    $end            reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)
    RBRACE          reduce using rule 22 (foreach -> FOR LPAREN VAR ID OF ID RPAREN block .)


state 160

    (21) for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .

    VAR             reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    CONST           reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    ID              reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    INTERFACE       reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    IF              reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    WHILE           reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    FOR             reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    BREAK           reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    CONTINUE        reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    RETURN          reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    CONSOLE         reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    $end            reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)
    RBRACE          reduce using rule 21 (for -> FOR LPAREN declaration SEMICOLON exp SEMICOLON declaration RPAREN block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 54 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for MOD in state 146 resolved as shift
WARNING: shift/reduce conflict for COMPARASION in state 146 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 146 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 146 resolved as shift
WARNING: shift/reduce conflict for LESS in state 146 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 146 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 146 resolved as shift
